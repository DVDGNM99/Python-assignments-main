#!/usr/bin/env python3
"""
GUI app (Tkinter) for selecting multiple brain regions and rendering them in BrainRender.

How it works:
- Reads "regions.json" from the same folder (mapping ACRONYM -> Full Name). not all the brain areas in the json can be used some standard ones are: MOs, VISp, ACA, TH, APN
- Each row shows a dropdown ("ACRONYM — Full Name"). Click the + button to add more rows, and - to eliminate them.
- Click "Render" to open the 3D BrainRender window with all selected regions.

If "regions.json" is missing or empty, the script will auto-build a list from the atlas
and save "regions_autogenerated.json" for future runs.
"""

import json
import os
import sys
import tkinter as tk
from tkinter import ttk, messagebox

from brainglobe_atlasapi import BrainGlobeAtlas
from brainrender import Scene


# ---------- Config ----------
JSON_FILENAME = "regions.json"                 # expected JSON in the same folder
AUTO_JSON_FILENAME = "regions_autogenerated.json"
DEFAULT_ALPHA = 0.5
DEFAULT_COLOR = None                           # let brainrender pick defaults if None
ATLAS_NAME = "allen_mouse_25um"
# Predefined color palette (name is informational only)
PRESET_COLORS = [
    ("steel", "#4682B4"), ("crimson", "#DC143C"), ("orange", "#FFA500"), ("forest", "#228B22"),
    ("violet", "#8A2BE2"), ("teal", "#008080"), ("gold", "#FFD700"), ("slate", "#708090"),
    ("pink", "#FF69B4"), ("turquoise", "#40E0D0"), ("indigo", "#4B0082"), ("chocolate", "#D2691E"),
]

# Default color for newly added rows
DEFAULT_ROW_COLOR = PRESET_COLORS[0][1]

# ----------------------------


def script_dir() -> str:
    """Return the directory where this script resides (works when launched from anywhere)."""
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    return os.path.dirname(os.path.abspath(__file__))


def load_regions_from_json() -> dict:
    """
    Load regions from JSON in the same folder as the script.
    Expected formats:
      1) {"MOs": "Secondary motor area", "VISp": "Primary visual area", ...}
      2) [{"acronym": "MOs", "name": "Secondary motor area"}, ...]
    Returns {acronym: name}
    """
    folder = script_dir()
    json_path = os.path.join(folder, JSON_FILENAME)

    if os.path.exists(json_path):
        try:
            with open(json_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            if isinstance(data, dict):
                return {str(k): str(v) for k, v in data.items()}
            if isinstance(data, list):
                out = {}
                for item in data:
                    ac = str(item.get("acronym", "")).strip()
                    nm = str(item.get("name", "")).strip()
                    if ac and nm:
                        out[ac] = nm
                if out:
                    return out
        except Exception as e:
            messagebox.showwarning("regions.json error", f"Failed to parse regions.json:\n{e}")

    # Fallback: build from atlas and save an auto file
    try:
        print(">> regions.json not found or invalid. Building region list from atlas...")
        atlas = BrainGlobeAtlas(ATLAS_NAME)
        # atlas.structures is typically a dict of structures with fields including 'acronym' and 'name'
        # We collect those that have both fields.
        regions = {}
        for sid, entry in atlas.structures.items():
            ac = str(entry.get("acronym", "")).strip()
            nm = str(entry.get("name", "")).strip()
            if ac and nm:
                regions[ac] = nm

        if regions:
            auto_path = os.path.join(folder, AUTO_JSON_FILENAME)
            with open(auto_path, "w", encoding="utf-8") as f:
                json.dump(regions, f, ensure_ascii=False, indent=2)
            messagebox.showinfo(
                "Autogenerated regions",
                f"Could not load '{JSON_FILENAME}'.\n"
                f"Built regions from atlas and saved '{AUTO_JSON_FILENAME}'.\n"
                "The GUI will use this autogenerated list."
            )
            return regions
        else:
            raise RuntimeError("No regions found in atlas.")
    except Exception as e:
        messagebox.showerror("Region list error",
                             f"Could not obtain region list from JSON or atlas.\n{e}")
        return {}


def display_items_from_mapping(mapping: dict) -> list:
    """
    Build list of display strings "ACRONYM — Full name", sorted by acronym.
    """
    items = [f"{ac} — {nm}" for ac, nm in mapping.items()]
    items.sort(key=lambda s: s.split(" — ", 1)[0].lower())
    return items

class PaletteDialog(tk.Toplevel):
    """Simple modal dialog with a grid of color buttons (no labels)."""
    def __init__(self, master, on_pick, *args, **kwargs):
        super().__init__(master, *args, **kwargs)
        self.title("Pick a color")
        self.resizable(False, False)
        self.on_pick = on_pick

        pad = 8
        cols = 6  # tweak columns as you like
        for i, (_, hexcol) in enumerate(PRESET_COLORS):
            r, c = divmod(i, cols)
            btn = tk.Button(
                self, width=4, height=2,
                bg=hexcol, activebackground=hexcol,
                command=lambda h=hexcol: self._choose(h)
            )
            btn.grid(row=r, column=c, padx=pad, pady=pad)

        # Modal
        self.bind("<Escape>", lambda e: self.destroy())
        self.transient(master)
        self.grab_set()
        self.focus_set()

    def _choose(self, hexcol: str):
        try:
            if callable(self.on_pick):
                self.on_pick(hexcol)
        finally:
            self.destroy()



class RegionRow(ttk.Frame):
    """
    One row: (1) a readonly Combobox with region display text,
             (2) a clickable color square showing the current color.
    Use get_acronym() and get_color() to retrieve values.
    """
    def __init__(self, master, choices: list, init_color: str = DEFAULT_ROW_COLOR, **kwargs):
        super().__init__(master, **kwargs)
        self.var = tk.StringVar(value="")
        self.color = init_color

        # Regions combobox
        self.combo = ttk.Combobox(
            self, textvariable=self.var, values=choices, state="readonly", width=48
        )
        self.combo.grid(row=0, column=0, sticky="ew", padx=(0, 6))

        # Color square (clickable)
        self.color_square = tk.Canvas(self, width=22, height=22,
                                      highlightthickness=1, highlightbackground="#aaa")
        self.color_square.grid(row=0, column=1, sticky="w")
        self._square_id = self.color_square.create_rectangle(2, 2, 20, 20,
                                                             fill=self.color, outline="")
        self.color_square.bind("<Button-1>", self._on_color_click)

        self.columnconfigure(0, weight=1)

    def _on_color_click(self, *_):
        def _set(hexcol: str):
            self.color = hexcol
            self.color_square.itemconfig(self._square_id, fill=self.color)
        PaletteDialog(self, on_pick=_set)

    def get_acronym(self) -> str:
        text = self.var.get()
        # Expect "ACR — Name"
        if " — " in text:
            return text.split(" — ", 1)[0].strip()
        return ""

    def get_color(self) -> str:
        return self.color


class GUIApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("BrainRender — Region Selector (Tkinter)")
        self.geometry("640x320")

        # Load region mapping
        self.mapping = load_regions_from_json()
        if not self.mapping:
            # If still empty, disable UI
            lbl = ttk.Label(self, text="No region list available. See console for errors.", foreground="red")
            lbl.pack(padx=16, pady=16)
            return

        self.choices = display_items_from_mapping(self.mapping)

        # Top bar with + and - buttons
        top = ttk.Frame(self)
        top.pack(fill="x", padx=12, pady=(12, 6))

        # "+" button to add new rows
        self.add_button = ttk.Button(top, text="+", width=3, command=self.add_row)
        self.add_button.pack(side="right", padx=(4, 0))

        # "-" button to remove the last added row
        self.remove_button = ttk.Button(top, text="–", width=3, command=self.remove_row)
        self.remove_button.pack(side="right")

        # Container for rows
        self.rows_frame = ttk.Frame(self)
        self.rows_frame.pack(fill="both", expand=True, padx=12, pady=6)
        self.rows = []

        # Add first row by default
        self.add_row()

        # Bottom bar with Render button
        bottom = ttk.Frame(self)
        bottom.pack(fill="x", padx=12, pady=(6, 12))

        self.render_btn = ttk.Button(bottom, text="Render", command=self.on_render)
        self.render_btn.pack(side="right")

        # Nice resizing
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)

    def add_row(self):
        # Rotate default colors across preset palette for visual variety
        idx = len(self.rows) % len(PRESET_COLORS)
        row = RegionRow(self.rows_frame, self.choices, init_color=PRESET_COLORS[idx][1])
        row.pack(fill="x", pady=4)
        self.rows.append(row)

    def remove_row(self):
        if len(self.rows) > 1:
           row = self.rows.pop()
           row.destroy()
        else:
           messagebox.showinfo("Cannot remove", "At least one selection row must remain.")



    def on_render(self):
        # Collect selections preserving order and avoiding duplicates
        seen = set()
        selected = []  # list of (acronym, color_hex)
        for r in self.rows:
            ac = r.get_acronym()
            if ac and ac not in seen:
                seen.add(ac)
                selected.append((ac, r.get_color()))

        if not selected:
            messagebox.showwarning("No regions selected", "Please pick at least one brain region.")
            return

        try:
            # Load atlas and render
            print(f">> Loading atlas '{ATLAS_NAME}' (first run may take a few minutes)...")
            atlas = BrainGlobeAtlas(ATLAS_NAME)
            print("Atlas loaded:", atlas.metadata.get("name"), "| resolution:", atlas.resolution)
            print("Number of structures:", len(atlas.structures))

            scene = Scene(atlas_name=ATLAS_NAME)
            for ac, color_hex in selected:
                scene.add_brain_region(ac, alpha=DEFAULT_ALPHA, color=color_hex)
                print(f"Added region {ac} (alpha={DEFAULT_ALPHA}, color={color_hex})")

            print(">> Opening 3D window... (close it to exit)")
            scene.render()
        except Exception as e:
            messagebox.showerror("Render error", f"Failed to render regions.\n{e}")




if __name__ == "__main__":
    app = GUIApp()
    app.mainloop()
