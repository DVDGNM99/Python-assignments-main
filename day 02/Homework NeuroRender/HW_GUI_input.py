#!/usr/bin/env python3
"""
GUI app (Tkinter) for selecting multiple brain regions and rendering them in BrainRender.

How it works:
- Reads "regions.json" from the same folder (mapping ACRONYM -> Full Name). not all the brain areas in the json can be used some standard ones are: MOs, VISp, ACA, TH, APN
- Each row shows a dropdown ("ACRONYM — Full Name"). Click the + button to add more rows, and - to eliminate them.
- Click "Render" to open the 3D BrainRender window with all selected regions.

If "regions.json" is missing or empty, the script will auto-build a list from the atlas
and save "regions_autogenerated.json" for future runs.
"""

import json
import os
import sys
import tkinter as tk
from tkinter import ttk, messagebox

from brainglobe_atlasapi import BrainGlobeAtlas
from brainrender import Scene


# ---------- Config ----------
JSON_FILENAME = "regions.json"                 # expected JSON in the same folder
AUTO_JSON_FILENAME = "regions_autogenerated.json"
DEFAULT_ALPHA = 0.5
DEFAULT_COLOR = None                           # let brainrender pick defaults if None
ATLAS_NAME = "allen_mouse_25um"
# ----------------------------


def script_dir() -> str:
    """Return the directory where this script resides (works when launched from anywhere)."""
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    return os.path.dirname(os.path.abspath(__file__))


def load_regions_from_json() -> dict:
    """
    Load regions from JSON in the same folder as the script.
    Expected formats:
      1) {"MOs": "Secondary motor area", "VISp": "Primary visual area", ...}
      2) [{"acronym": "MOs", "name": "Secondary motor area"}, ...]
    Returns {acronym: name}
    """
    folder = script_dir()
    json_path = os.path.join(folder, JSON_FILENAME)

    if os.path.exists(json_path):
        try:
            with open(json_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            if isinstance(data, dict):
                return {str(k): str(v) for k, v in data.items()}
            if isinstance(data, list):
                out = {}
                for item in data:
                    ac = str(item.get("acronym", "")).strip()
                    nm = str(item.get("name", "")).strip()
                    if ac and nm:
                        out[ac] = nm
                if out:
                    return out
        except Exception as e:
            messagebox.showwarning("regions.json error", f"Failed to parse regions.json:\n{e}")

    # Fallback: build from atlas and save an auto file
    try:
        print(">> regions.json not found or invalid. Building region list from atlas...")
        atlas = BrainGlobeAtlas(ATLAS_NAME)
        # atlas.structures is typically a dict of structures with fields including 'acronym' and 'name'
        # We collect those that have both fields.
        regions = {}
        for sid, entry in atlas.structures.items():
            ac = str(entry.get("acronym", "")).strip()
            nm = str(entry.get("name", "")).strip()
            if ac and nm:
                regions[ac] = nm

        if regions:
            auto_path = os.path.join(folder, AUTO_JSON_FILENAME)
            with open(auto_path, "w", encoding="utf-8") as f:
                json.dump(regions, f, ensure_ascii=False, indent=2)
            messagebox.showinfo(
                "Autogenerated regions",
                f"Could not load '{JSON_FILENAME}'.\n"
                f"Built regions from atlas and saved '{AUTO_JSON_FILENAME}'.\n"
                "The GUI will use this autogenerated list."
            )
            return regions
        else:
            raise RuntimeError("No regions found in atlas.")
    except Exception as e:
        messagebox.showerror("Region list error",
                             f"Could not obtain region list from JSON or atlas.\n{e}")
        return {}


def display_items_from_mapping(mapping: dict) -> list:
    """
    Build list of display strings "ACRONYM — Full name", sorted by acronym.
    """
    items = [f"{ac} — {nm}" for ac, nm in mapping.items()]
    items.sort(key=lambda s: s.split(" — ", 1)[0].lower())
    return items


class RegionRow(ttk.Frame):
    """
    One row: a dropdown (combobox) bound to a stringvar.
    The dropdown shows "ACRONYM — Full name", but we expose a helper to get the raw acronym.
    """
    def __init__(self, master, choices: list, **kwargs):
        super().__init__(master, **kwargs)
        self.var = tk.StringVar(value="")
        self.combo = ttk.Combobox(self, textvariable=self.var, values=choices, state="readonly", width=48)
        self.combo.grid(row=0, column=0, sticky="ew")
        self.columnconfigure(0, weight=1)

    def get_acronym(self) -> str:
        text = self.var.get()
        # Expect "ACR — Name"
        if " — " in text:
            return text.split(" — ", 1)[0].strip()
        # If user didn't pick anything, return empty
        return ""


class GUIApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("BrainRender — Region Selector (Tkinter)")
        self.geometry("640x320")

        # Load region mapping
        self.mapping = load_regions_from_json()
        if not self.mapping:
            # If still empty, disable UI
            lbl = ttk.Label(self, text="No region list available. See console for errors.", foreground="red")
            lbl.pack(padx=16, pady=16)
            return

        self.choices = display_items_from_mapping(self.mapping)

        # Top bar with + and - buttons
        top = ttk.Frame(self)
        top.pack(fill="x", padx=12, pady=(12, 6))

        # "+" button to add new rows
        self.add_button = ttk.Button(top, text="+", width=3, command=self.add_row)
        self.add_button.pack(side="right", padx=(4, 0))

        # "-" button to remove the last added row
        self.remove_button = ttk.Button(top, text="–", width=3, command=self.remove_row)
        self.remove_button.pack(side="right")

        # Container for rows
        self.rows_frame = ttk.Frame(self)
        self.rows_frame.pack(fill="both", expand=True, padx=12, pady=6)
        self.rows = []

        # Add first row by default
        self.add_row()

        # Bottom bar with Render button
        bottom = ttk.Frame(self)
        bottom.pack(fill="x", padx=12, pady=(6, 12))

        self.render_btn = ttk.Button(bottom, text="Render", command=self.on_render)
        self.render_btn.pack(side="right")

        # Nice resizing
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)

    def add_row(self):
        row = RegionRow(self.rows_frame, self.choices)
        row.pack(fill="x", pady=4)
        self.rows.append(row)
    def remove_row(self):
        if len(self.rows) > 1:
            row = self.rows.pop()
            row.destroy()
        else:
            messagebox.showinfo("Cannot remove", "At least one selection bar must remain.")


    def on_render(self):
        # Collect selected acronyms
        acronyms = [r.get_acronym() for r in self.rows if r.get_acronym()]
        # Deduplicate while keeping order
        seen = set()
        selected = []
        for ac in acronyms:
            if ac not in seen:
                seen.add(ac)
                selected.append(ac)

        if not selected:
            messagebox.showwarning("No regions selected", "Please pick at least one brain region.")
            return

        try:
            # Load atlas and render
            print(f">> Loading atlas '{ATLAS_NAME}' (first run may take a few minutes)...")
            atlas = BrainGlobeAtlas(ATLAS_NAME)
            print("Atlas loaded:", atlas.metadata.get("name"), "| resolution:", atlas.resolution)
            print("Number of structures:", len(atlas.structures))

            scene = Scene(atlas_name=ATLAS_NAME)
            for ac in selected:
                scene.add_brain_region(ac, alpha=DEFAULT_ALPHA, color=DEFAULT_COLOR)
                print(f"Added region {ac} (alpha={DEFAULT_ALPHA}, color={DEFAULT_COLOR})")

            print(">> Opening 3D window... (close it to exit)")
            scene.render()
        except Exception as e:
            messagebox.showerror("Render error", f"Failed to render regions.\n{e}")


if __name__ == "__main__":
    app = GUIApp()
    app.mainloop()
